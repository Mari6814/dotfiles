export SOURCED=".aliases:$SOURCED"

# Modify the default values for builtins
alias grep="grep --color=auto"
alias ls="ls -CFG --color=auto"

# Shortcut to update and upgrade linux distributions
alias aptuu="sudo apt -y update && sudo apt -y upgrade"
# Shortcut to start editing temporary file. First argument is the file extension
etmp() { nvim "$(mktemp)$1"; }
# print something in red to stderr
err() { tput setaf 1; echo error: "$@" 1>&2; }
# Shortcut for opening the default editor
alias e="$EDITOR"
# Clear shortcut
alias c=clear
# Default vim to nvim
alias vim=nvim
# Makedir always verbose and full path
alias mkdir="mkdir -pv"
# List used ports?
alias ports="netstat -tulanp"
# Follow a file's output
alias follow="tail -f"
# Search for an expression in directory and children
alias contains="grep -rnw . -e"
# Important 'ls' shortcuts
alias ll='ls -alFh'
alias la='ls -A'
alias l='ls -CF'
# Shortcut to make new dir and cd into it
md() {
    mkdir -p "$@" && cd "$@"
}

# Shortcuts to editing and sourcsing shell files
_edit_then_source() { e "$1" && source "$1"; }

if [ "$SHELL" = "/bin/bash" ]; then
    # Bash specific settings files
    alias erc="_edit_then_source ~/.bashrc"
    alias eenv="_edit_then_source ~/.bash_env"
    alias ealias="_edit_then_source ~/.bash_aliases"
    alias eprofile="_edit_then_source ~/.bash_profile"
    alias ehist="e ~/.bash_history"
elif [ "$SHELL" = "/bin/zsh" ]; then
    # Zsh specific settings files
    alias erc="_edit_then_source ~/.zshrc"
    alias eenv="_edit_then_source ~/.zshenv"
    alias eprofile="_edit_then_source ~/.zprofile"
    alias ealias="_edit_then_source ~/.zsh_aliases"
    alias ehist="e ~/.zsh_history"
fi

# Edit vim config
alias evim="e ~/.vimrc"
alias envim="e ~/.config/nvim/init.vim"

# Git shortcut
alias gs="git status"
alias gv="git remote -v"
alias gb="git branch"
alias gd="git diff"
alias gcam="git commit -am"

# Shortcut for using tensorboard with the current dir as logdir
alias tb="tensorboard --logdir ."
# Shortcut for python
alias py="python3"
# Shortcut for ipython
alias ipy="ipython"
# Shortcut for using a module with python3
alias m="python3 -m"
# Poetry shortcut
alias p="poetry"
# Venv activate shortcut
alias va="source .venv/bin/activate"
# Open jupyter notebook
alias jn="jupyter notebook"

# Create executable bash script and edit it
# The first argument as the path to the script file that will be created
cmd() {
    local NAME="${1:?'Usage: cmd <cmdname>'}"
    if [ -e "$NAME" ]; then
        err "Command already exists: $NAME"
        return 1
    fi
    echo "Creating command: $NAME"
    echo '#!/bin/bash' >> "$NAME"
    e "$NAME"
    chmod +x "$NAME"
}

# Start recording the history and add it to an executable script file
# The first argument as the file that will be saved
rec() {
    local NAME="${1:?'Usage: rec <cmdname>'}"
    [ -e "$NAME" ] && err "Command already exists: $NAME" && return 1
    tee "$NAME" | ($SHELL && chmod +x "$NAME")
}

# Encrypt some input
encrypt() {
    [ -z "$1" ] && echo "usage: encrypt <outfile>" && return 1
    [ -e "$1" ] && err "File $1 already exists." && return 1
    local secret=$(openssl aes-256-cbc -e -a -salt -pbkdf2 -iter 100000)
    echo "#!/bin/sh" >> "$1"
    echo "echo \"$secret\" | openssl aes-256-cbc -d -a -salt -pbkdf2 -iter 100000 \$@" >> "$1"
    chmod +x "$1"
}

# A helper function that makes a new "local" directory.
# Adds subdirectories to appropiate paths
function make-local {
    local USAGE="usage: make-local [-h|--help] [--dir] <dir>"
    if [ $# -eq 0 ]; then
        echo "$USAGE" >&2
        return 0
    fi
    while test $# -gt 0; do
        case "$1" in
            -h|--help)
                echo "$USAGE" >&2
                return 0
                ;;
            -d|--dir)
                shift
                DIR="$1"
                ;;
            *)
                DIR="$1"
        esac
        shift
    done
    if [ -z "$DIR" ]; then
        echo "$USAGE" >&2
        return 1
    fi
    if [ ! -d "$DIR" ]; then
        err "$DIR is not a directory"
        return 1
    fi
    [ -d "$DIR/bin" ] && export PATH="$DIR/bin:$PATH"
    [ -d "$DIR/lib" ] && export LD_LIBRARY_PATH="$DIR/lib:$LD_LIBRARY_PATH"
    [ -d "$DIR/lib64" ] && export LD_LIBRARY_PATH="$DIR/lib64:$LD_LIBRARY_PATH"
    [ -d "$DIR/include" ] && export CPATH="$CPATH/include:$CPATH"
    [ -d "$DIR/man" ] && export MANPATH="$MANPATH/man:$MANPATH"
}

# Create a virtual folder out of a glob. This function creates a directory
# called <dirname> and links all files from the provided globs into that directory
mkvirtual() {
    local USAGE="usage: <dirname> FILE [FILES ...]"
    if [ -z "$1" ]; then
        err "Missing first argument <dirname>"
        echo $USAGE
        return 1
    fi
    if [ -z "$2" ]; then
        err "Missing 2nd argument [FILE ...]"
        echo $USAGE
        return 1
    fi
    local DIRNAME="$1"
    shift
    mkdir "$DIRNAME"
    for path in "$@"; do
        ln -vs "$(realpath $path)" "$DIRNAME/$(basename $path)"
    done
}

# List ports in use
ls-ports() {
    lsof -i tcp -s tcp:listen | awk '$8 == "TCP" { split($9,a,":"); print a[2] }'
}

# Forward port given by an input argument in the form "host:port"
forward-host-port() {
    if [ -z $1 ]; then
        err "Missing argument <hostname:port>"
        return 1
    fi
    local HOST=$(echo $1 | awk '{ split($1,a,":"); print a[1] }')
    local PORT=$(echo $1 | awk '{ split($1,a,":"); print a[2] }')
    ssh -NL "${PORT:-$2}:localhost:$PORT" "$HOST"
}

# Execute command for-each directory
for-each-directory() {
    ls -d */ | xargs -I {} bash -c "cd '{}' && $1"
}

# Shortcut that creates a git ignore file with the listed patterns added to it
gignore() {
    for pattern in "$@"; do
        echo "$pattern" >> .gitignore
    done
    tac .gitignore
}

# Virtaul env auto
Cd() {
    builtin cd $@
    if [ -z "$VIRTUAL_ENV" ]; then
        if [ -f .venv/bin/activate ]; then
            . .venv/bin/activate
        fi
    else
        local CURRENT="$(realpath $(pwd))"
        local ROOT="$(realpath $VIRTUAL_ENV/..)"
        case $CURRENT/ in
            $ROOT/*) ;; # Still inside venv
            *) deactivate;; # Not in venv hierarchy anymore
        esac
    fi
}

# wait for jobs until the number of jobs is lower than the barrier
barrier() {
    if [ -z "$1" || "$1" = "-h" || "$1" = "--help" ]; then
        echo "Usage: barrier <limit> [intervall=1]" >&2
        return 1
    fi
    local LIMIT="$1"
    local INTERVALL="${2:-1}"
    while true; do
        if [ $(jobs | wc -l) -lt $LIMIT ]; then
            break
        fi
        sleep $INTERVALL
    done
}

# Source machine local aliases inside the `$HOME/.local` directory
if [ -f "$LOCAL/bash_aliases" ] && [ '/bin/bash' = "$SHELL" ]; then
    source "$LOCAL/bash_aliases"
elif [ -f "$LOCAL/zsh_aliases" ] && [ '/bin/zsh' = "$SHELL" ]; then
    source "$LOCAL/zsh_aliases"
fi
if [ -f "$LOCAL/aliases" ]; then
    source "$LOCAL/aliases"
fi

