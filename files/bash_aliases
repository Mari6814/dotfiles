# Mark this as loaded
export BASH_ALIASES="$BASH_SOURCE:$BASH_ALIASES"
export SOURCED="$BASH_SOURCE:$SOURCED"

# Shortcut to update and upgrade linux distributions
alias aptuu="sudo apt -y update && sudo apt -y upgrade"

# Execute command for-each directory
for-each() {
    ls -d */ | xargs -I {} bash -c "cd '{}' && $1"
}

# Start recording to the usual database
alias r="script -a $HOME/.bash_database"

# Remove all ansi sequences from a stored file.
remove-ansi-sequences() {
    cat "$1" | perl -pe '
s/\e\[[\x30-\x3f]*[\x20-\x2f]*[\x40-\x7e]//g;
s/\e[PX^_].*?\e\\//g;
s/\e\][^\a]*(?:\a|\e\\)//g;
s/\e[\[\]A-Z\\^_@]//g;'
}

# Fix permissions of files and directories recursiveley
fix-permissions() {
    local USAGE="Usage: fix-permissions <directory>"
    sudo find ${1:?$USAGE} -type f -exec chmod 0664 {} +
    sudo find $1 -type d -exec chmod 0775 {} +
}

# Shortcut that creates a git ignore file with the listed files added to it
gignore() {
    for file in "$@"; do
        echo "$file" >> .gitignore
    done
    tac .gitignore
}

# Shortcut to start editing temporary file.
alias etmp="vim $(mktemp)"

# easy back cd command
alias ..="Cd .."

# Poetry CLI shortcut
alias p=poetry

# Virtaul env auto
Cd() {
    builtin cd $@
    if [ -z "$VIRTUAL_ENV" ]; then
        if [ -f .venv/bin/activate ]; then
            . .venv/bin/activate
        fi
    else
        local CURRENT="$(realpath $(pwd))"
        local ROOT="$(realpath $VIRTUAL_ENV/..)"
        case $CURRENT/ in
            $ROOT/*) ;; # Still inside venv
            *) deactivate;; # Not in venv hierarchy anymore
        esac
    fi
}

# wait for jobs until the number of jobs is lower than the barrier
barrier() {
    if [ -z "$1" ]; then
        echo "Usage: barrier <limit> [intervall=1]" >&2
        return 1
    fi
    local LIMIT="$1"
    local INTERVALL="${2:-1}"
    while true; do
        if [ $(jobs | wc -l) -lt $LIMIT ]; then
            break
        fi
        sleep $INTERVALL
    done
}

# shortcut for printing with "error:" prefixed red text to stderr
alias err=">&2 tput setaf 1; echo error:"

# Create a virtual folder out of a glob This function creates a directory
# called <dirname> and links all files from the rest glob into that directory
mkvdir() {
    local USAGE="usage: <dirname> FILE [FILES ...]"
    if [ -z "$1" ]; then
        echo $USAGE >&2
        return 1
    fi
    if [ -z "$2" ]; then
        echo "err: Missing glob output as argument 2.." >&2
        echo $USAGE >&2
        return 1
    fi
    local DIRNAME="$1"
    shift
    mkdir "$DIRNAME"
    for path in "$@"; do
        ln -vs "$(realpath $path)" "$DIRNAME/$(basename $path)"
    done
}

# List ports in use
ls-ports() {
    lsof -i tcp -s tcp:listen | awk '$8 == "TCP" { split($9,a,":"); print a[2] }'
}

# Forward port given by an input argument in the form "host:port"
forward-host-port() {
    if [ -z $1 ]; then
        err "Missing argument <hostname:port>"
        return 1
    fi
    local HOST=$(echo $1 | awk '{ split($1,a,":"); print a[1] }')
    local PORT=$(echo $1 | awk '{ split($1,a,":"); print a[2] }')
    ssh -NL "${PORT:-$2}:localhost:$PORT" "$HOST"
}

# Shortcut for opening the EDITOR variable
alias e="$EDITOR $@"

# Edit bashrc
alias ebash="e ~/.bashrc && source ~/.bashrc"

# Edit bash_profile
alias ebashprofile="e ~/.bash_profile && source ~/.bash_profile"

# Edit profile
alias eprofile="e ~/.profile && source ~/.profile"

# Edit bash aliases
alias ealias="e ~/.bash_aliases && source ~/.bash_aliases"

# Edit vim config
alias evim="e ~/.vimrc"

# Open last session in vim/nvim or specify a specific session file as argument
# $1
erestore() {
    local SESS="${1:-$HOME/.vim/Session.vim}"
    if [ -f "$SESS" ]; then
        echo "Loading $SESS"
        e -S "$SESS"
    else
        err No session file exists.
        return 1
    fi
}

# Edit nvim config
alias envim="e ~/.config/nvim/init.vim"

# keep tailing a file
alias follow="tail -f"

# Search for a pattern in any file from the current cwd
alias contains="grep -rnw . -e"

# Git shortcut
alias gs="git status"
alias gb="git branch"
alias gr="git remote -v"
alias gd="git diff"
alias gdt="git difftool -y"

# Git shortcut for the common `git commit -am`
alias gcam="git commit -am"

# Create executable bash script and edit it
# The first argument as the path to the script file that will be created
cmd() {
    local NAME="${1:?'Usage: cmd <cmdname>'}"
    [ -e $NAME ] && echo "Command already exists: $NAME" && return 1
    echo "Creating command: $NAME"
    echo '#!/bin/bash' >> "$NAME"
    e "$NAME"
    chmod +x "$NAME"
}

# Start recording the history and add it to an executable script file
# The first argument as the file that will be saved
rec() {
    local FILE="${1:?'Usage: reccmd <cmdname>'}"
    [ -e $FILE ] && echo "Command already exists: $FILE" && return 1
    tee "$FILE" | (bash && chmod +x "$FILE")
}

# Shortcut for using tensorboard with the current dir as logdir
alias tb="tensorboard --logdir ."

# Shortcut for jupyter notebook starting at default port 55500 that can be
# overwritten using the first argument or a global variable called `$PORT`
jn() {
    local port="${1:-${PORT:-55500}}"
    shift
    jupyter notebook --no-browser --port $port $@
}

# Shortcut for python
alias py=python3

# Shortcut for listing running jupyter notebooks
alias jl="jupyter notebook list"

# Shortcut for ipython
alias ipy=ipython

# Shortcut for using a module with python3
alias m="python3 -m"

# Shortcut for automatically sourcing a */bin/activate script which usually
# activates a venv
vactivate() {
    source ${1:-?(.)*}/bin/activate;
}

# Shortcut for activating virtual environments in .venv/bin/activate
alias va=vactivate

# Shortcut for deactivating a virtual env. Virtual envs add a `deactivate`
# script to the path that can be triggered to deactivate it
alias vd=deactivate


# Variable to hold the path to a personal quick notes file
export NOTES_FILE="$HOME/notes.txt"

# List installed alternatives
alias altl="update-alternatives --list"

# Configure alternatives
alias altc="sudo update-alternatives --config"

# Remove alternatives
alias altrm="sudo update-alternatives --remove"

# Remove all alternatives
alias altrmall="sudo update-alternatives --remove-all"

# Register alternatives in .local/bin
# alt <name> <path to alternative> [prio=10]
alt() {
    if [ -z "$1" ] | [ -z "$2" ]; then
        err "Usage: alt <name> <path> [priority = 10]"
        return 1
    fi
    if [ ! -f "$2" ]; then
        err "The <path> argument must point to an executable file."
        return 1
    fi
    local NAME="$1"
    local APATH="$2"
    local PRIO="${3:-10}"
    echo "Linking $APATH -> $NAME"
    sudo update-alternatives --install "$HOME/.local/bin/$NAME" "$NAME" "$APATH" "$PRIO"
}

# Append all arguments to the notes file at `$NOTES_FILE`
note() {
    echo "$@" >> $NOTES_FILE
}

# Shortcut for the `note` function
alias n=note

# List the contents of the `$NOTES_FILE`
alias notes="cat $NOTES_FILE"

# Encrypt some input
encrypt() {
    [ -z "$1" ] && echo "usage: encrypt <outfile>" && return 1
    [ -e "$1" ] && echo "err: File $1 already exists." && return 1
    local secret=$(openssl aes-256-cbc -e -a -salt -pbkdf2 -iter 100000)
    echo "#!/bin/sh" >> "$1"
    echo "echo \"$secret\" | openssl aes-256-cbc -d -a -salt -pbkdf2 -iter 100000 \$@" >> "$1"
    chmod +x "$1"
}
#
# A helper function that makes a new "local" directory.
# Adds subdirectories to appropiate paths
function make-local {
    local USAGE="usage: make-local [-h|--help] [--dir] <dir>"
    if [ $# -eq 0 ]; then
        echo "$USAGE" >&2
        return 0
    fi
    while test $# -gt 0; do
        case "$1" in
            -h|--help)
                echo "$USAGE" >&2
                return 0
                ;;
            -d|--dir)
                shift
                DIR="$1"
                ;;
            *)
                DIR="$1"
        esac
        shift
    done
    if [ -z "$DIR" ]; then
        echo "$USAGE" >&2
        return 1
    fi
    if [ ! -d "$DIR" ]; then
        echo "err: $DIR is not a directory" >&2
        return 1
    fi
    [ -d "$DIR/bin" ] && export PATH="$DIR/bin:$PATH"
    [ -d "$DIR/lib" ] && export LD_LIBRARY_PATH="$DIR/lib:$LD_LIBRARY_PATH"
    [ -d "$DIR/lib64" ] && export LD_LIBRARY_PATH="$DIR/lib64:$LD_LIBRARY_PATH"
    [ -d "$DIR/include" ] && export CPATH="$CPATH/include:$CPATH"
    [ -d "$DIR/man" ] && export MANPATH="$MANPATH/man:$MANPATH"
}


# Source machine local aliases inside the `$HOME/.local` directory
if [ -f $HOME/.local/bash_aliases ]; then
    . $HOME/.local/bash_aliases
fi
