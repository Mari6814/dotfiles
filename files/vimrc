set nocompatible
set t_Co=256

call plug#begin('~/.vim/plugged')
Plug 'junegunn/goyo.vim'
Plug 'airblade/vim-gitgutter'
" Plug 'preservim/nerdtree'
" Plug 'tpope/vim-surround'
Plug 'morhetz/gruvbox'
if has('nvim')
    Plug 'neovim/nvim-lspconfig'
    Plug 'hrsh7th/cmp-nvim-lsp'
    Plug 'hrsh7th/cmp-buffer'
    Plug 'hrsh7th/cmp-path'
    Plug 'hrsh7th/cmp-cmdline'
    Plug 'hrsh7th/nvim-cmp'
    Plug 'nvim-lua/plenary.nvim'
    Plug 'nvim-telescope/telescope.nvim'
    Plug 'github/copilot.vim'
    Plug 'hrsh7th/cmp-vsnip'
    Plug 'hrsh7th/vim-vsnip'
endif
call plug#end()

syntax on
filetype plugin on
filetype plugin indent on
colorscheme gruvbox
set cursorline
set number
set visualbell
set ruler
set encoding=utf-8
set wrap
set textwidth=0
set formatoptions=tcqrn1
set tabstop=4
set shiftwidth=4
set expandtab
set showmode
set showcmd
set hlsearch
set incsearch
set ignorecase
set smartcase
set showmatch
set listchars=trail:·,nbsp:⎵,eol:¬,tab:▸\ ,extends:>,precedes:<
set list
set matchpairs+=<:>
set hidden
set wildmenu
set foldmethod=indent
set foldnestmax=10
set foldlevel=2
" Enable this option if pasting text into vim
set pastetoggle=<F2>
set ai
set wildignore+=**/node_modules/**,*.pyc,*.o,
set switchbuf=useopen,vsplit
filetyp plugin on
" Specify python3 executable for some extension?
let g:python3_host_prog = "/usr/bin/python3"
" Enable paste register crossplattform
set clipboard^=unnamed,unnamedplus
set completeopt=menu,menuone,noselect

" Forces block cursor for some terminals that don't have it already
let &t_ti.="\e[1 q"
let &t_SI.="\e[5 q"
let &t_EI.="\e[1 q"
let &t_te.="\e[0 q"

" Naviagte windows in normal mode by holding ctrl
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-h> <C-w>h
nnoremap <C-l> <C-w>l
inoremap <C-j> <c-o><C-w>j
inoremap <C-k> <c-o><C-w>k
inoremap <C-h> <c-o><C-w>h
inoremap <C-l> <c-o><C-w>l
" Toggle folds using space
nnoremap <space> za
" Open nerd tree
nnoremap <leader>b :vs `pwd`<cr>
" Shortcut search for beginnig of word
nnoremap gw /\<
nnoremap gW ?\<
inoremap <silent><expr> <C-Space> compe#complete()
" inoremap <silent><expr> <CR>      compe#confirm('<CR>')
inoremap <silent><expr> <C-e>     compe#close('<C-e>')
" Open :ls and enter :b to start typing searched buffer
nnoremap gb :ls<cr>:b<space>

" Close current buffer
nnoremap <leader>q :bwipe<cr>
" Find files using Telescope command-line sugar.
nnoremap <leader>ff <cmd>Telescope find_files<cr>
nnoremap <leader>fg <cmd>Telescope live_grep<cr>
nnoremap <leader>fb <cmd>Telescope buffers<cr>
nnoremap <leader>fh <cmd>Telescope help_tags<cr>
" Goto any file using ctrl+p behaviour
nnoremap <c-p> :Telescope find_files<cr>
" Search string under cursor using Telescope
nnoremap <leader>f yiw:Telescope grep_string<cr><c-r>0

" Replace word under cursor
nnoremap <leader>r :s/<C-r><C-w>//<left>
" Search and replace the word under the cursor
nnoremap <leader>R :%s/<C-r><C-w>//g<left><left>
" Search and replace the current visual selection
vnoremap <leader>v ygv:s/<c-r>"//<left>
" Search the pattern under the cursor in all files with the same extension as this one
nnoremap <F4> :execute ':vim /<C-r><C-w>/ **/*'<cr>
" Shortcut to replace word under cursor and enabling the . command
nmap g* *Ncgn

" Auto for session management
augroup sessions
    au!
    " Automatically save sessions on exit only in global dir
    au VimLeave * :mksession! ~/.vim/Session.vim
augroup end
" Open last global session that was saved
command Restore source ~/.vim/Session.vim

" Add syntax highlighting to zsh/bash and generic .aliases files
augroup aliases
    au!
    au BufReadPost .aliases set syntax=bash
    au BufReadPost .zsh_aliases set syntax=zsh
    au BufReadPost .bash_aliases set syntax=bash
augroup end

" Auto reload vimrc on save
augroup vimrc
    autocmd!
    autocmd FileType vim noremap <F1> :help <C-r><C-w><CR>
    autocmd BufWritePost,FileWritePost .vimrc :so $HOME/.vimrc
augroup end

" Only highlight search while in command line mode
augroup vimrc-incsearch-highlight
    autocmd!
    autocmd CmdlineEnter /,\? :set hlsearch
    autocmd CmdlineLeave /,\? :set nohlsearch
augroup END

" In the event, that a large file was loaded, set some options to reduce lag
augroup LargeFile
        let g:large_file = 2621440 " 2.5MB
        " Set options:
        "   eventignore+=FileType (no syntax highlighting etc
        "   assumes FileType always on)
        "   noswapfile (save copy of file)
        "   bufhidden=unload (save memory when other file is viewed)
        "   buftype=nowritefile (is read-only)
        "   undolevels=-1 (no undo possible)
        au BufReadPre *
                \ let f=expand("<afile>") |
                \ if getfsize(f) > g:large_file |
                        \ set eventignore+=FileType |
                        \ setlocal noswapfile bufhidden=unload buftype=nowrite undolevels=-1 |
                \ else |
                        \ set eventignore-=FileType |
                \ endif
augroup end

" Custom statusline section
function! StatuslineGit()
  let l:branchname = system("git rev-parse --abbrev-ref HEAD 2>/dev/null | tr -d '\n'")
  return strlen(l:branchname) > 0?'  '.l:branchname.' ':''
endfunction

set statusline=
set statusline+=%#PmenuSel#
set statusline+=%{StatuslineGit()}
set statusline+=%#LineNr#
set statusline+=\ %f\ %m
set statusline+=\ "
set statusline+=%=
set statusline+=%#CursorColumn#
set statusline+=\ %y
set statusline+=\ %{&fileencoding?&fileencoding:&encoding}
set statusline+=\[%{&fileformat}\]
set statusline+=\ %p%%
set statusline+=\ %l:%c
set statusline+=\ "

lua <<EOF
  -- Setup nvim-cmp.
  local cmp = require'cmp'

  cmp.setup({
    snippet = {
      -- REQUIRED - you must specify a snippet engine
      expand = function(args)
        vim.fn["vsnip#anonymous"](args.body) -- For `vsnip` users.
        -- require('luasnip').lsp_expand(args.body) -- For `luasnip` users.
        -- require('snippy').expand_snippet(args.body) -- For `snippy` users.
        -- vim.fn["UltiSnips#Anon"](args.body) -- For `ultisnips` users.
      end,
    },
    window = {
      -- completion = cmp.config.window.bordered(),
      -- documentation = cmp.config.window.bordered(),
    },
    mapping = cmp.mapping.preset.insert({
      ['<C-b>'] = cmp.mapping.scroll_docs(-4),
      ['<C-f>'] = cmp.mapping.scroll_docs(4),
      ['<C-Space>'] = cmp.mapping.complete(),
      ['<C-e>'] = cmp.mapping.abort(),
      ['<CR>'] = cmp.mapping.confirm({ select = true }), -- Accept currently selected item. Set `select` to `false` to only confirm explicitly selected items.
    }),
    sources = cmp.config.sources({
      { name = 'nvim_lsp' },
      { name = 'vsnip' }, -- For vsnip users.
      -- { name = 'luasnip' }, -- For luasnip users.
      -- { name = 'ultisnips' }, -- For ultisnips users.
      -- { name = 'snippy' }, -- For snippy users.
    }, {
      { name = 'buffer' },
    })
  })

  -- Set configuration for specific filetype.
  cmp.setup.filetype('gitcommit', {
    sources = cmp.config.sources({
      { name = 'cmp_git' }, -- You can specify the `cmp_git` source if you were installed it.
    }, {
      { name = 'buffer' },
    })
  })

  -- Use buffer source for `/` (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline('/', {
    mapping = cmp.mapping.preset.cmdline(),
    sources = {
      { name = 'buffer' }
    }
  })

  -- Use cmdline & path source for ':' (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline(':', {
    mapping = cmp.mapping.preset.cmdline(),
    sources = cmp.config.sources({
      { name = 'path' }
    }, {
      { name = 'cmdline' }
    })
  })
EOF
